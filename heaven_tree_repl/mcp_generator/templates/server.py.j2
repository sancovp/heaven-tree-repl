"""
{{ config.description }} - TreeShell MCP Server

Auto-generated MCP server for TreeShell application.
Generated by heaven-tree-repl MCP Generator.
"""
import json
import os
from enum import Enum
from typing import Sequence

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent
from mcp.shared.exceptions import McpError

# Import TreeShell and user application
import sys
{% for path in config.import_path.split('.')[:-1] %}
sys.path.insert(0, '{{ path }}')
{% endfor %}

from heaven_tree_repl import render_response
from {{ config.import_path }} import {{ config.factory_function }}


class {{ config.get_mcp_server_class_name() }}Tools(str, Enum):
    """Available {{ config.app_name }} tools"""
    {{ config.tool_name.upper() }} = "{{ config.tool_name }}"


class {{ config.get_mcp_server_class_name() }}:
    """
    {{ config.description }}
    
    TreeShell MCP Server providing access to {{ config.app_name }} functionality
    through a clean tree navigation interface.
    """
    
    def __init__(self):
        """Initialize the {{ config.app_name }} MCP server"""
        self.shell = None
        self._initialize_shell()

    def _find_user_config(self, heaven_data_dir: str, library_prefix: str) -> str:
        """Find user config directory for this library in HEAVEN_DATA_DIR."""
        try:
            if not os.path.exists(heaven_data_dir):
                return None
            for item in os.listdir(heaven_data_dir):
                if item.startswith(library_prefix):
                    item_path = os.path.join(heaven_data_dir, item)
                    if os.path.isdir(item_path):
                        configs_path = os.path.join(item_path, 'configs')
                        if os.path.exists(configs_path):
                            return configs_path
            return None
        except Exception:
            return None

    def _initialize_shell(self):
        """Initialize the {{ config.app_name }} shell"""
        try:
            # Set HEAVEN_DATA_DIR if not set
            heaven_data = os.getenv('HEAVEN_DATA_DIR', '/tmp/heaven_data')
            os.environ['HEAVEN_DATA_DIR'] = heaven_data
            os.makedirs(heaven_data, exist_ok=True)
            {% for env_var, default_value in config.environment_vars.items() %}
            # Set {{ env_var }} if not set
            if not os.getenv('{{ env_var }}'):
                os.environ['{{ env_var }}'] = '{{ default_value }}'
                {% if env_var.endswith('_DIR') %}
                os.makedirs('{{ default_value }}', exist_ok=True)
                {% endif %}
            {% endfor %}

            # Find user config from HEAVEN_DATA_DIR
            user_config_path = self._find_user_config(heaven_data, '{{ config.get_package_name() }}')

            # Get the {{ config.app_name }} shell (TreeShell instance)
            self.shell = {{ config.factory_function }}(user_config_path=user_config_path)
            
        except Exception as e:
            print(f"Warning: Could not initialize {{ config.app_name }} shell: {e}")
            self.shell = None
    
    async def {{ config.tool_name }}(self, command: str) -> dict:
        """
        Run a command in the {{ config.app_name }} TreeShell.
        
        Args:
            command: TreeShell command to execute
            
        Returns:
            Dict with command result
        """
        if not self.shell:
            return {
                "success": False,
                "error": "{{ config.app_name }} TreeShell not initialized. Check environment variables and dependencies."
            }
        
        try:
            # Handle command through TreeShell
            result = await self.shell.handle_command(command)
            
            # Render the result using TreeShell's renderer
            rendered_output = render_response(result)
            
            return {
                "success": True,
                "command": command,
                "rendered_output": rendered_output,
                "raw_result": result
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Error executing command '{command}': {str(e)}"
            }


async def serve() -> None:
    """Main MCP server function"""
    server = Server("{{ config.server_name }}")
    {{ config.get_package_name() }}_server = {{ config.get_mcp_server_class_name() }}()
    
    @server.list_tools()
    async def list_tools() -> list[Tool]:
        """List available {{ config.app_name }} tools"""
        return [
            Tool(
                name={{ config.get_mcp_server_class_name() }}Tools.{{ config.tool_name.upper() }}.value,
                description="""
                {{ config.description }}
                
                TreeShell provides tree-based navigation with persistent state management.
                
                ## Core Navigation Commands:
                - '' (empty) - Show current menu/options
                - 'jump X.Y.Z' - Navigate to specific coordinate (e.g., 'jump 0.1.1')
                - 'back' - Go back to previous position
                - 'menu' - Show current node menu
                - 'exit' - Exit TreeShell
                
                ## Action Execution:
                - NUMBER - Execute numbered menu option (e.g., '1', '2', '3')
                - NUMBER + JSON - Execute with arguments (e.g., '1 {"param": "value"}')
                - NUMBER, args={...} - Alternative argument format
                
                ## Navigation Examples:
                1. '' - Show main menu
                2. '1' - Execute first menu option
                3. 'jump 0.1.2' - Navigate to specific coordinate
                4. '1 {"key": "value"}' - Execute with parameters
                """,
                inputSchema={
                    "type": "object",
                    "properties": {
                        "command": {
                            "type": "string",
                            "description": "TreeShell command to execute (e.g., 'jump 0.1.1', '1 {\"param\": \"value\"}', or '' for menu)",
                        }
                    },
                    "required": ["command"],
                },
            ),
        ]
    
    @server.call_tool()
    async def call_tool(name: str, arguments: dict) -> Sequence[TextContent]:
        """Handle tool calls"""
        try:
            match name:
                case {{ config.get_mcp_server_class_name() }}Tools.{{ config.tool_name.upper() }}.value:
                    command = arguments.get("command", "")
                    result = await {{ config.get_package_name() }}_server.{{ config.tool_name }}(command)
                    
                    # Return only the rendered output, not the full JSON
                    if result.get("success"):
                        output_text = result.get("rendered_output", "No output available")
                    else:
                        output_text = f"‚ùå Error: {result.get('error', 'Unknown error')}"
                
                case _:
                    raise ValueError(f"Unknown tool: {name}")
            
            return [
                TextContent(type="text", text=output_text)
            ]
        
        except Exception as e:
            raise ValueError(f"Error processing {{ config.app_name }} operation: {str(e)}")
    
    # Initialize server and run
    options = server.create_initialization_options()
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, options)


if __name__ == "__main__":
    import asyncio
    asyncio.run(serve())